\documentclass[a4paper,10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{hyperref}

\newcommand{\icon}[1]{\tikz[baseline=-3pt] \node[inner sep=0pt,outer sep=0pt]{\includegraphics[height=1.1em]{images/#1}};}

%opening
\title{ADAMS - Scientific Workflow Management}
\author{Peter Reutemann}

\begin{document}

\chapter{Twitter Research}
ADAMS offers a large amount of actors for a wide range of data processing and mining tasks. However, we limit ourselves here to the analysis of data obtained from Twitter. The following sections cover how to set up ADAMS in order to access Twitter, how to collect tweets for further (and repeated) analysis, replay previously collected tweets, visualize tweets and how to perform various analyses.

%%%%%%%%%%%%%%%%%
% Twitter setup %
%%%%%%%%%%%%%%%%%
\section{Twitter setup}
ADAMS uses the twitter4j\footnote{\url{http://twitter4j.org/}{}} library for accessing Twitter. In order to access some of the functionality of the Twitter API, you need to have a developer account and register an application to get the required API key/secret and Access token/secret. You can register an application on the Twitter Developer website\footnote{\url{https://dev.twitter.com/}{}} for free. Figure \ref{twitter_dev} shows an example website for an ADAMS application, complete with generated API key/secret and Access token/secret. Once you have obtained these keys/tokens/secrets you can enter them in the ADAMS preferences page for Twitter, as shown in Figure \ref{twitter_preferences}. These preferences are global and get picked up by the \icon{TwitterConnection}~TwitterConnection actor as default values, which you can always override, in case you need different credentials.

\begin{figure}[htb]
  \centering
  \includegraphics[width=10.0cm]{images/twitter_dev.png}
  \caption{Application management through the ``Twitter Developers'' website, displaying keys, tokens and secrets for an application.}
  \label{twitter_dev}
\end{figure}

\begin{figure}[htb]
  \centering
  \includegraphics[width=10.0cm]{images/twitter_preferences.png}
  \caption{Preferences page for Twitter in ADAMS.}
  \label{twitter_preferences}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%
% Collecting tweets %
%%%%%%%%%%%%%%%%%%%%%
\clearpage
\newpage
\section{Collecting tweets}
Rather than just obtaining the tweets of a single user, Twitter allows you to tap into the stream of tweets as they are posted in real-time using their streaming API\footnote{\url{https://dev.twitter.com/docs/streaming-apis}{}}. However, Twitter distinguishes between the ``fire hose'' and the ``garden hose''. The former being the complete stream of tweets, which is only accessible to paying customers that have sufficient bandwidth and hardware to cope with the flood of information. The latter is a 1\% sample of the complete stream, which available to the public. The ``garden hose'' is what can be accessed using ADAMS.

According to Twitter's API Rules, you can collect tweets, but you are not allowed to redistribute them.\footnote{See \url{https://twitter.com/apirules}{} for more details.} ADAMS therefore fills the void of publicly available tweet archives, by allowing you to collect a large corpus of tweets yourself. You simply set up a flow for collecting tweets and let it run for a number of days, weeks or even months.

In order to collect tweets, you basically only need the following three actors:
\begin{itemize}
  \item \icon{TwitterConnection}~\textbf{TwitterConnection} -- for connecting to Twitter.
  \item \icon{TwitterListener}~\textbf{TwitterListener} -- for accessing the ``garden hose'' stream of tweets.
  \item \icon{TwitterConverter}~\textbf{TwitterConverter} -- for turning the tweets into a data format suitable for future analysis, e.g., spreadsheet format.
\end{itemize}
Unless you are storing the data in a database, the generated tweet archive file will get rather large, since there are several million tweets coming through the ``garden hose'' every single day. The flow depicted in Figure \ref{collect_tweets-flow} saves the tweets in a special ADAMS CSV (comma-separated values) file format, which is also the recommended format for replaying the tweets. In order to avoid too large an output file, the tweets get grouped by day. 

The flow works as follows:
\begin{itemize}
  \item Since we need the file name generation more than once in the flow and we do not want to duplicate the functionality, we push the generation into \icon{CallableActors}~CallableActors, which basically acts as a function call. The file name generation consists of several steps, i.e., we need to encapsulate them in a \icon{SequenceSource}~SequenceSource called ``filename''.
  
  \item The \icon{TwitterListener}~TwitterListener source is configured to output an unlimited number of tweets, i.e., the user needs to explicitly stop the flow before the collection of tweets finishes.
  
  \item To begin with, the \icon{Once}~Once control actor\footnote{As the name suggests, the \textit{Once} actor triggers its nested actors only with the first token passing through, as opposed to the default \textit{Trigger} actor which executes its nested actors each time a token passes through.} initializes the variable obtaining the current file name by executing the callable actor ``filename'' through the \icon{CallableSource}~CallableSource source actor and setting the variable with the \icon{SetVariable}~SetVariable actor.

  \item Every 1000 tweets, the \icon{ConditionalTrigger}~ConditionalTrigger control actor executes its nested actors, checking whether a newly generate CSV file name differs from the one currently stored in the variable \texttt{@\{filename\}}.
    \begin{itemize}
      \item Should that be the case, i.e., the \icon{ConditionalTee}~ConditionalTee actor evaluates to true, the variable \texttt{@\{filename\}} gets updated using the \icon{SetVariable}~SetVariable transformer.
    \end{itemize}
  
  \item Each tweet gets converted into a spreadsheet object using the \icon{TwitterConverter}~TwitterConverter transformer, selecting all data fields deemed important.
  
  \item The generated spreadsheet object then gets stored in the CSV file with the \icon{SpreadSheetFileWriter}~SpreadSheetFileWriter sink, using the current file name stored in the variable \texttt{@\{filename\}}.
\end{itemize}


\begin{figure}[htb]
  \centering
  \includegraphics[width=8.0cm]{images/collect_tweets-flow.png}
  \caption{Flow for collecting tweets in CSV archive files.}
  \label{collect_tweets-flow}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Replaying and filtering tweets %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\newpage
\section{Replaying and filtering tweets}
Once you have collected a sufficiently large archive of tweets, you can start experimenting with them. As a first step, we want to demonstrate how you can replay existing archives and how to filter tweets according to user-specified criteria.

\subsection{Basic replay and filtering}
Figure \ref{replay_and_filter_tweets-flow} shows a flow that performs some basic filtering of replayed tweets:

\begin{itemize}
  \item The \icon{TweetReplay}~TweetReplay source replays tweets using the specified tweet replay mechanism, in this case an ADAMS CSV archive.
  
  \item In this case, we want to look into sentiment analysis and therefore only allow tweets that contain a ``happy'' or a ``sad'' smiley icon. This is done using the \icon{TwitterFilter}~TwitterFilter transformer, which allows you to specify a filter expression. You have access to, if present, the status text, user, language, country, place, ``mentions'', hashtags and GPS location.
  
  \item The \icon{TwitterConverter}~TwitterConverter transformer is used to turn the tweet objects into a textual representation, simply using the status text.
  
  \item The generated text output is then visualized in a simple text viewer, the \icon{Display}~Display sink.
\end{itemize}

\begin{figure}[htb]
  \centering
  \includegraphics[width=10.0cm]{images/replay_and_filter_tweets-flow.png}
  \caption{Flow for replaying and filtering tweets from a CSV archive, using simple textual output.}
  \label{replay_and_filter_tweets-flow}
\end{figure}

However, if you generated more than one CSV archive, you don't want to manually change the flow each time you want to process another archive file. Using the variable mechanism in ADAMS, you can easily automate the traversal of all the CSV archive files in a directory. Figure \ref{replay_and_filter_tweets-multiple_files-flow} shows how this is done:

\begin{itemize}
  \item With the \icon{DirectoryLister}~DirectoryLister source, you can search directories using a regular expression and output files and/or directories. In our case, we want to output all CSV files (``\texttt{.*\textbackslash.csv}'').
  
  \item The \icon{SetVariable}~SetVariable transformer stores the file names that the \icon{DirectoryLister}~DirectoryLister outputs in the variable \texttt{@\{file\}}.
  
  \item The \icon{Trigger}~Trigger control actor encapsulates now the flow that was introduced in Figure \ref{replay_and_filter_tweets-flow}. However, the ``archive'' option of the SpreadSheetConverterArchive tweet replay mechanism now has the variable \texttt{@\{file\}} attached to it, rather than a fixed file name. This way we will replay one CSV file after the other.
\end{itemize}

\begin{figure}[htb]
  \centering
  \includegraphics[width=12.0cm]{images/replay_and_filter_tweets-multiple_files-flow.png}
  \caption{Flow for replaying and filtering tweets from multiple CSV archives, using simple textual output.}
  \label{replay_and_filter_tweets-multiple_files-flow}
\end{figure}

\subsection{Plotting calculated values}
Now, simply outputting the status texts of the filtered tweets is not overly interesting, we want to answer some questions with the data that we have collected. For instance, how does the distribution of ``happy'' and ``sad'' smileys change over time?

In order to keep track of the number of tweets in either category, we will use variables to store the counts (per minute in this example). For visualizing, we will use a plotter actor that displays the two curves.

The flow works as follows:
\begin{itemize}
  \item Initialize the \texttt{@\{timetamp\}} variable with an empty string using the \icon{SetVariable-Standalone}~SetVariable standalone.

  \item The \icon{TweetReplay}~TweetReplay source replays a previously generated tweet archive.

  \item In the \icon{Trigger}~Trigger ``determine timestamp'' we determine the timestamp of the current tweet and, if it changed, plot the current counts of happy/sad smileys.
  \begin{itemize}
    \item The \icon{TwitterConverter}~TwitterConverter outputs a ``per minute'' timestamp for the \texttt{CREATED} tweet field.
    \item If \icon{ConditionalTee} ``timestamp changed?'' determines that the new timestamp differs from the old one, we do the following:
    \begin{itemize}
      \item If the \texttt{@\{timestamp\}} variable is not empty, i.e., we have counts for the previous minute available and we want to plot them. This gets determined by the \icon{ConditionalTrigger}~ConditionalTrigger ``plot?''. The actual plotting is explained below.
      \item Record the new timestamp as the current one, using the \icon{SetVariable}~SetVariable actor.
    \end{itemize}
  \end{itemize}
  
  \item The \icon{ConditionalTrigger}~ConditionalTrigger ``happy'' evaluates to true if the twitter text contains a happy smiley and accordingly increments the ``happy'' counter variable using \icon{IncVariable}~IncVariable.
  
  \item The \icon{ConditionalTrigger}~ConditionalTrigger ``sad'' works like the ``happy'' one.
\end{itemize}
The \icon{SequencePlotter}~SequencePlotter sink accepts special ``plot'' containers, which we can generate using the \icon{MakePlotContainer}~MakePlotContainer transformer. This transformer accepts either a single double (``y'') or a double array of length two (``x'' and ``y''). We will generate these plot containers using the timestamp and counts stored in variables, converting them to doubles in the process. Therefore the plotting of the happy/sad counts works as follows (sub-flow beneath the \icon{ConditionalTrigger}~ConditionalTrigger ``plot?''):
\begin{itemize}
  \item In the \icon{Trigger}~Trigger ``timestamp to double'' we are converting the previous ``minute'' timestamp string into milli-seconds (Java epoch) using the \icon{Convert}~Convert transformer in conjunction with the StringToDateTimeType conversion and store the result in the \texttt{@\{timestamp\_double\}} variable.
  
  \item The ``plot happy'' \icon{Trigger}~Trigger then outputs the \texttt{@\{timestamp\_double\}} and \texttt{@\{happy\}} variables as string array, converts it to a double array using the \icon{ArrayProcess}~ArrayProcess control actor with the nested \icon{Convert}~Convert actor (using the StringToDouble conversion), creates a plot container using the \icon{MakePlotContainer}~MakePlotContainer transformer (labeled ``happy'') and feeds it into the call-able \icon{SequencePlotter}~SequencePlotter sink using the \icon{CallableSink}~CallableSink actor.
  
  \item The ``plot sad'' sub-flow works similar.
  
  \item The \icon{SetVariable}~SetVariable transformers ``reset happy'' and ``reset sad'' reset the counters to 0 for the next minute.
\end{itemize}
Figure \ref{replay_and_filter_tweets2-output} shows the generated plot from a small tweet archive that spans only a few minutes. Apart from the fact that people seem to post more ``happy'' smileys, not much else can be gleaned from this plot. However, when we aggregate the counts over hours rather than minutes, it is possible to trends much better. Figure \ref{twitter_mood} shows the smiley distribution over New Years 2013/14\footnote{In the early hours of the new year, a network outage prohibited the collection of tweets. However, the general trend is not much affected by that.}. You can clearly see that the ``sad'' smileys follow closely the ``happy'' ones, though at a reduced rate. But around the changeover of years, the counts for the ``happy'' smileys skyrocket before settling back to a more normal behavior. The smaller bump later in the day on New Years is probably due to people getting up and replying to tweets that they received the night before.

\begin{figure}[htb]
  \centering
  \includegraphics[width=8.0cm]{images/replay_and_filter_tweets2-flow.png}
  \caption{Flow for replaying and filtering tweets from a CSV archive, displaying mood distribution per minute.}
  \label{replay_and_filter_tweets2-flow}
\end{figure}

\begin{figure}[htb]
  \centering
  \includegraphics[width=10.0cm]{images/replay_and_filter_tweets2-output.png}
  \caption{Visualization of mood distribution per minute (``happy'' and ``sad'' smiley counts).}
  \label{replay_and_filter_tweets2-output}
\end{figure}

\begin{figure}[htb]
  \centering
  \includegraphics[width=12.0cm]{images/twitter_mood.png}
  \caption{Visualization of mood distribution per hour over New Years 2013/2014 (``happy'' and ``sad'' smiley counts).}
  \label{twitter_mood}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%
% Visualizing tweets %
%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\newpage
\section{Visualizing tweets}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Visualizing tweets - Analysis %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Analysis}
TODO

\begin{figure}[htb]
  \centering
  \includegraphics[width=12.0cm]{images/visualize_tweets-archive-flow.png}
  \caption{Flow for visualizing tweets archive.}
  \label{visualize_tweets-archive-flow}
\end{figure}

\begin{figure}[htb]
  \centering
  \includegraphics[width=10.0cm]{images/visualize_tweets-archive-output.png}
  \caption{Flow for visualizing tweets archive.}
  \label{visualize_tweets-archive-output}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Visualizing tweets - Real-time visualization %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Real-time visualization}
TODO

\begin{figure}[htb]
  \centering
  \includegraphics[width=12.0cm]{images/visualize_tweets-realtime-flow.png}
  \caption{Flow for visualizing tweets in real-time.}
  \label{visualize_tweets-realtime-flow}
\end{figure}

\end{document}
